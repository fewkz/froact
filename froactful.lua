-- This file is generated by generate.py and not intended to be edited.
--!strict
local froact = {}

export type DefaultPropertyConfig = {
	class: string,
	property: string,
	value: any,
}
type ComponentConfig = {
	pure: boolean?,
	name: string?,
}

local isAMemo = {}
local function isA(class: string, ancestor: string)
	local key = class .. "-" .. ancestor
	if isAMemo[key] then
		return isAMemo[key]
	end
	local instance: Instance = Instance.new(class :: any)
	isAMemo[key] = instance:IsA(ancestor)
	return isAMemo[key]
end

type Element = any
-- type Children = Element | { Element } | nil
type Children = any? -- For simpler definitions, since it's the equivalent as above

local function newE(roact: any, hooks, defaults: { DefaultPropertyConfig })
	return function(class: string, props: { [string]: any }, children: Children)
		for _, default in defaults do
			if isA(class, default.class) and not props[default.property] then
				props[default.property] = default.value
			end
		end
		return roact.createElement(class, props, children)
	end
end

local function newTemplate(roact: any, unpureByDefault: boolean?)
	type CleanupMethod = () -> ()
	type UpdateMethod<Props> = (props: Props) -> CleanupMethod
	type Constructor<Props> = (
		name: string,
		parent: Instance,
		onUpdate: (UpdateMethod<Props>) -> ()
	) -> CleanupMethod
	return function<Props>(config: ComponentConfig, f: Constructor<Props>)
		local isPure = if config.pure == nil then not unpureByDefault else config.pure
		local Component = if isPure
			then roact.PureComponent:extend(config.name or "Component")
			else roact.Component:extend(config.name or "Component")
		function Component:init()
			local _className, hostKey, hostParent, _children
			for name, field in self do
				if tostring(name) == "Symbol(InternalData)" then
					_className = field.componentClass
					hostKey = field.virtualNode.hostKey
					hostParent = field.virtualNode.hostParent
					_children = field.virtualNode.children
				end
			end
			self.updateCallbacks = {}
			self.updateCleanups = {}
			self.cleanup = f(hostKey, hostParent, function(callback)
				table.insert(self.updateCleanups, callback(self.props))
				table.insert(self.updateCallbacks, f)
			end)
		end
		function Component:render()
			return roact.createFragment()
		end
		function Component:didUpdate()
			for _, cleanup in self.updateCleanups do
				cleanup()
			end
			self.updateCleanups = {}
			for _, callback in self.updateCallbacks do
				table.insert(self.updateCleanups, callback(self.props))
			end
		end
		function Component:willUnmount()
			for _, cleanup in self.updateCleanups do
				cleanup()
			end
			self.cleanup()
		end
		return function(props: Props, children)
			return roact.createElement(Component, props, children)
		end
	end
end

-- stylua: ignore
type ListConfig = (
	{ orderByName: boolean?, setOrder: true, initial: number?, key: string? }
	| { orderByName: boolean?, setOrder: false?, initial: nil, key: string? }
)
local function newList(roact: any)
	return function(config: ListConfig, elements: { [number]: Element })
		local index = if config.initial then config.initial else 0
		local count: { [string]: number } = {}
		local dict = {}
		local nameFormat = "%0" .. math.floor(math.log10(#elements) + 1) .. "i | %s" -- For orderByName
		for _, element in elements do
			local isRobloxClass = typeof(element.component) == "string"
			local className = if isRobloxClass
				then element.component
				else element.component.__componentName

			local sortType = if not isRobloxClass
				then "Component"
				else if isRobloxClass and isA(element.component, "GuiObject")
					then "Instance"
					else "None"

			local key = if config.key and element.props[config.key]
				then element.props[config.key]
				else className
			if config.orderByName and sortType ~= "None" then
				index += 1
				key = string.format(nameFormat, index, key)
			end
			if count[key] == 1 then
				dict[key .. " " .. count[key]] = dict[key]
				dict[key] = nil
			end
			if count[key] then
				count[key] += 1
				dict[key .. " " .. count[key]] = element
			else
				count[key] = 1
				dict[key] = element
			end

			if config.setOrder and sortType == "Instance" then
				index += 1
				element.props.LayoutOrder = index
			elseif config.setOrder and sortType == "Component" then
				index += 1
				element.props.layoutOrder = index
			end
		end
		return roact.createFragment(dict)
	end
end

local blankChildren = table.freeze({})

type HookFunction<Props, Hooks> = (render: (Props, Hooks) -> any, options: any) -> any

local function newC<Hooks>(roact: any, hooks: HookFunction<any, Hooks>, unpureByDefault: boolean?)
	return function<Props>(
		config: ComponentConfig,
		body: (Props, Hooks, { Element }) -> any
	): (Props, Children) -> any
		local isPure = if config.pure == nil then not unpureByDefault else config.pure
		-- Wrap the body to have children passed in as a third argument
		local function wrappedBody(props: any, hooks)
			local children = props[roact.Children]
			props[roact.Children] = nil
			return body(props, hooks, if children then children else blankChildren)
		end
		local Component = hooks(wrappedBody, {
			componentType = if isPure then "PureComponent" else "Component",
			name = if config.name then config.name else "Component",
		})
		return function(props, children)
			return roact.createElement(Component, props, children)
		end
	end
end

type Ref = { current: any }
local function newCreateRef(roact: any): () -> Ref
	return roact.createRef
end

type Binding<T> = { getValue: (self: Binding<T>) -> T }
local function newCreateBinding(roact: any): <T>(default: T) -> (Binding<T>, (T) -> ())
	return roact.createBinding
end

type BindingPairs<T...> = { map: <O>(self: BindingPairs<T...>, f: (T...) -> O) -> Binding<O> }
local function newJoin(roact: any): (
	(<A>(b1: Binding<A>) -> BindingPairs<A>)
	& (<A, B>(b1: Binding<A>, b2: Binding<B>) -> BindingPairs<A, B>)
	& (<A, B, C>(b1: Binding<A>, b2: Binding<B>, b3: Binding<C>) -> BindingPairs<A, B, C>)
	& (<A, B, C, D>(
		b1: Binding<A>,
		b2: Binding<B>,
		b3: Binding<C>,
		b4: Binding<D>
	) -> BindingPairs<A, B, C, D>)
)
	return (
		function(...)
			local bindings = { ... }
			local joined = roact.joinBindings(bindings)
			return {
				map = function(self, f)
					return joined:map(function(a)
						return f(unpack(a))
					end)
				end,
			}
		end
	) :: any
end

local function newMap(roact: any): <T, O>(binding: Binding<T>, f: (T) -> O) -> Binding<O>
	return function(binding: any, f)
		return binding:map(f)
	end
end

-- We write our own Hooks type. Might make froact incompatible
-- with different versions of RoactHooks, although it's unlikely
-- there'd be a breaking change any time soon. We could consider
-- vendoring our own RoactHooks eventually.
-- One opinionated change we make is not making dependencies optional.
-- forgetting to include dependencies is a very easy way to
-- shoot yourself in the foot optimization-wise.
type Hooks = {
	useBinding: <T>(defaultValue: T) -> (Binding<T>, (newValue: T) -> ()),
	useCallback: <A..., R...>(
		callback: (A...) -> R...,
		dependencies: { unknown }
	) -> (A...) -> R...,
	useEffect: (callback: () -> (), dependencies: { unknown }) -> (),
	useMemo: <T...>(factory: () -> T..., dependencies: { unknown }) -> T...,
	useReducer: <S, A>(
		reducer: (state: S, action: A) -> S,
		initialState: S
	) -> (S, (action: A) -> ()),
	useState: <T>(default: T | (() -> T)) -> (T, (value: T) -> ()),
}

-- stylua: ignore start
type Event<Rbx, A...> = (rbx: Rbx, A...) -> ()
type BindProperty<Rbx> = (rbx: Rbx) -> ()
type InstanceProps<Rbx> = { Archivable: boolean | Binding<boolean>?, Name: string | Binding<string>?, Parent: Instance? | Binding<Instance?>?, onAncestryChanged: Event<Rbx, Instance, Instance?>?, onAttributeChanged: Event<Rbx, string>?, onChanged: Event<Rbx, string>?, onChildAdded: Event<Rbx, Instance>?, onChildRemoved: Event<Rbx, Instance>?, onDescendantAdded: Event<Rbx, Instance>?, onDescendantRemoving: Event<Rbx, Instance>?, onDestroying: Event<Rbx>? }
type GuiObjectProps<Rbx> = GuiBase2dProps<Rbx> & { Active: boolean | Binding<boolean>?, AnchorPoint: Vector2 | Binding<Vector2>?, AutomaticSize: Enum.AutomaticSize | Binding<Enum.AutomaticSize>?, BackgroundColor3: Color3 | Binding<Color3>?, BackgroundTransparency: number | Binding<number>?, BorderColor3: Color3 | Binding<Color3>?, BorderMode: Enum.BorderMode | Binding<Enum.BorderMode>?, BorderSizePixel: number | Binding<number>?, ClipsDescendants: boolean | Binding<boolean>?, LayoutOrder: number | Binding<number>?, NextSelectionDown: GuiObject | Binding<GuiObject>?, NextSelectionLeft: GuiObject | Binding<GuiObject>?, NextSelectionRight: GuiObject | Binding<GuiObject>?, NextSelectionUp: GuiObject | Binding<GuiObject>?, Position: UDim2 | Binding<UDim2>?, Rotation: number | Binding<number>?, Selectable: boolean | Binding<boolean>?, SelectionImageObject: GuiObject | Binding<GuiObject>?, SelectionOrder: number | Binding<number>?, Size: UDim2 | Binding<UDim2>?, SizeConstraint: Enum.SizeConstraint | Binding<Enum.SizeConstraint>?, Transparency: number | Binding<number>?, Visible: boolean | Binding<boolean>?, ZIndex: number | Binding<number>?, onInputBegan: Event<Rbx, InputObject>?, onInputChanged: Event<Rbx, InputObject>?, onInputEnded: Event<Rbx, InputObject>?, onMouseEnter: Event<Rbx, number, number>?, onMouseLeave: Event<Rbx, number, number>?, onMouseMoved: Event<Rbx, number, number>?, onMouseWheelBackward: Event<Rbx, number, number>?, onMouseWheelForward: Event<Rbx, number, number>?, onSelectionGained: Event<Rbx>?, onSelectionLost: Event<Rbx>?, onTouchLongPress: Event<Rbx, { Vector2 }, Enum.UserInputState>?, onTouchPan: Event<Rbx, { Vector2 }, Vector2, Vector2, Enum.UserInputState>?, onTouchPinch: Event<Rbx, { Vector2 }, number, number, Enum.UserInputState>?, onTouchRotate: Event<Rbx, { Vector2 }, number, number, Enum.UserInputState>?, onTouchSwipe: Event<Rbx, Enum.SwipeDirection, number>?, onTouchTap: Event<Rbx, { Vector2 }>? }
type GuiBase2dProps<Rbx> = GuiBaseProps<Rbx> & { AutoLocalize: boolean | Binding<boolean>?, RootLocalizationTable: LocalizationTable | Binding<LocalizationTable>?, SelectionBehaviorDown: Enum.SelectionBehavior | Binding<Enum.SelectionBehavior>?, SelectionBehaviorLeft: Enum.SelectionBehavior | Binding<Enum.SelectionBehavior>?, SelectionBehaviorRight: Enum.SelectionBehavior | Binding<Enum.SelectionBehavior>?, SelectionBehaviorUp: Enum.SelectionBehavior | Binding<Enum.SelectionBehavior>?, SelectionGroup: boolean | Binding<boolean>?, bindAbsolutePosition: BindProperty<Rbx>?, bindAbsoluteRotation: BindProperty<Rbx>?, bindAbsoluteSize: BindProperty<Rbx>?, onSelectionChanged: Event<Rbx, boolean, GuiObject, GuiObject>? }
type GuiBaseProps<Rbx> = InstanceProps<Rbx>
type GuiButtonProps<Rbx> = GuiObjectProps<Rbx> & { AutoButtonColor: boolean | Binding<boolean>?, Modal: boolean | Binding<boolean>?, Selected: boolean | Binding<boolean>?, Style: Enum.ButtonStyle | Binding<Enum.ButtonStyle>?, onActivated: Event<Rbx, InputObject, number>?, onMouseButton1Click: Event<Rbx>?, onMouseButton1Down: Event<Rbx, number, number>?, onMouseButton1Up: Event<Rbx, number, number>?, onMouseButton2Click: Event<Rbx>?, onMouseButton2Down: Event<Rbx, number, number>?, onMouseButton2Up: Event<Rbx, number, number>? }
type GuiLabelProps<Rbx> = GuiObjectProps<Rbx>
type LayerCollectorProps<Rbx> = GuiBase2dProps<Rbx> & { Enabled: boolean | Binding<boolean>?, ResetOnSpawn: boolean | Binding<boolean>?, ZIndexBehavior: Enum.ZIndexBehavior | Binding<Enum.ZIndexBehavior>? }
type SurfaceGuiBaseProps<Rbx> = LayerCollectorProps<Rbx> & { Active: boolean | Binding<boolean>?, Adornee: Instance | Binding<Instance>?, Face: Enum.NormalId | Binding<Enum.NormalId>? }
type BasePartProps<Rbx> = PVInstanceProps<Rbx> & { Anchored: boolean | Binding<boolean>?, AssemblyAngularVelocity: Vector3 | Binding<Vector3>?, AssemblyLinearVelocity: Vector3 | Binding<Vector3>?, BackSurface: Enum.SurfaceType | Binding<Enum.SurfaceType>?, BottomSurface: Enum.SurfaceType | Binding<Enum.SurfaceType>?, BrickColor: BrickColor | Binding<BrickColor>?, CFrame: CFrame | Binding<CFrame>?, CanCollide: boolean | Binding<boolean>?, CanQuery: boolean | Binding<boolean>?, CanTouch: boolean | Binding<boolean>?, CastShadow: boolean | Binding<boolean>?, CollisionGroup: string | Binding<string>?, CollisionGroupId: number | Binding<number>?, Color: Color3 | Binding<Color3>?, CustomPhysicalProperties: PhysicalProperties | Binding<PhysicalProperties>?, FrontSurface: Enum.SurfaceType | Binding<Enum.SurfaceType>?, LeftSurface: Enum.SurfaceType | Binding<Enum.SurfaceType>?, LocalTransparencyModifier: number | Binding<number>?, Locked: boolean | Binding<boolean>?, Massless: boolean | Binding<boolean>?, Material: Enum.Material | Binding<Enum.Material>?, MaterialVariant: string | Binding<string>?, Orientation: Vector3 | Binding<Vector3>?, PivotOffset: CFrame | Binding<CFrame>?, Position: Vector3 | Binding<Vector3>?, Reflectance: number | Binding<number>?, RightSurface: Enum.SurfaceType | Binding<Enum.SurfaceType>?, RootPriority: number | Binding<number>?, Rotation: Vector3 | Binding<Vector3>?, Size: Vector3 | Binding<Vector3>?, TopSurface: Enum.SurfaceType | Binding<Enum.SurfaceType>?, Transparency: number | Binding<number>?, onTouchEnded: Event<Rbx, BasePart>?, onTouched: Event<Rbx, BasePart>? }
type PVInstanceProps<Rbx> = InstanceProps<Rbx> & { Origin: CFrame | Binding<CFrame>? }
type FormFactorPartProps<Rbx> = BasePartProps<Rbx>
type PartProps<Rbx> = FormFactorPartProps<Rbx> & { Shape: Enum.PartType | Binding<Enum.PartType>? }
type TriangleMeshPartProps<Rbx> = BasePartProps<Rbx>
type PartOperationProps<Rbx> = TriangleMeshPartProps<Rbx> & { UsePartColor: boolean | Binding<boolean>? }
type UIConstraintProps<Rbx> = UIComponentProps<Rbx>
type UIComponentProps<Rbx> = UIBaseProps<Rbx>
type UIBaseProps<Rbx> = InstanceProps<Rbx>
type UIGridStyleLayoutProps<Rbx> = UILayoutProps<Rbx> & { FillDirection: Enum.FillDirection | Binding<Enum.FillDirection>?, HorizontalAlignment: Enum.HorizontalAlignment | Binding<Enum.HorizontalAlignment>?, SortOrder: Enum.SortOrder | Binding<Enum.SortOrder>?, VerticalAlignment: Enum.VerticalAlignment | Binding<Enum.VerticalAlignment>?, bindAbsoluteContentSize: BindProperty<Rbx>? }
type UILayoutProps<Rbx> = UIComponentProps<Rbx>
type CameraProps = InstanceProps<Camera> & { CFrame: CFrame | Binding<CFrame>?, CameraSubject: Humanoid | BasePart | nil | Binding<Humanoid | BasePart | nil>?, CameraType: Enum.CameraType | Binding<Enum.CameraType>?, DiagonalFieldOfView: number | Binding<number>?, FieldOfView: number | Binding<number>?, FieldOfViewMode: Enum.FieldOfViewMode | Binding<Enum.FieldOfViewMode>?, Focus: CFrame | Binding<CFrame>?, HeadLocked: boolean | Binding<boolean>?, HeadScale: number | Binding<number>?, MaxAxisFieldOfView: number | Binding<number>?, onFirstPersonTransition: Event<Camera, boolean>?, onInterpolationFinished: Event<Camera>? }
type CanvasGroupProps = GuiObjectProps<CanvasGroup> & { GroupColor3: Color3 | Binding<Color3>?, GroupTransparency: number | Binding<number>? }
type FrameProps = GuiObjectProps<Frame> & { Style: Enum.FrameStyle | Binding<Enum.FrameStyle>? }
type ImageButtonProps = GuiButtonProps<ImageButton> & { HoverImage: string | Binding<string>?, Image: string | Binding<string>?, ImageColor3: Color3 | Binding<Color3>?, ImageRectOffset: Vector2 | Binding<Vector2>?, ImageRectSize: Vector2 | Binding<Vector2>?, ImageTransparency: number | Binding<number>?, PressedImage: string | Binding<string>?, ResampleMode: Enum.ResamplerMode | Binding<Enum.ResamplerMode>?, ScaleType: Enum.ScaleType | Binding<Enum.ScaleType>?, SliceCenter: Rect | Binding<Rect>?, SliceScale: number | Binding<number>?, TileSize: UDim2 | Binding<UDim2>? }
type TextButtonProps = GuiButtonProps<TextButton> & { Font: Enum.Font | Binding<Enum.Font>?, FontFace: Font | Binding<Font>?, LineHeight: number | Binding<number>?, MaxVisibleGraphemes: number | Binding<number>?, RichText: boolean | Binding<boolean>?, Text: string | Binding<string>?, TextColor3: Color3 | Binding<Color3>?, TextScaled: boolean | Binding<boolean>?, TextSize: number | Binding<number>?, TextStrokeColor3: Color3 | Binding<Color3>?, TextStrokeTransparency: number | Binding<number>?, TextTransparency: number | Binding<number>?, TextTruncate: Enum.TextTruncate | Binding<Enum.TextTruncate>?, TextWrapped: boolean | Binding<boolean>?, TextXAlignment: Enum.TextXAlignment | Binding<Enum.TextXAlignment>?, TextYAlignment: Enum.TextYAlignment | Binding<Enum.TextYAlignment>?, bindTextBounds: BindProperty<TextButton>? }
type ImageLabelProps = GuiLabelProps<ImageLabel> & { Image: string | Binding<string>?, ImageColor3: Color3 | Binding<Color3>?, ImageRectOffset: Vector2 | Binding<Vector2>?, ImageRectSize: Vector2 | Binding<Vector2>?, ImageTransparency: number | Binding<number>?, ResampleMode: Enum.ResamplerMode | Binding<Enum.ResamplerMode>?, ScaleType: Enum.ScaleType | Binding<Enum.ScaleType>?, SliceCenter: Rect | Binding<Rect>?, SliceScale: number | Binding<number>?, TileSize: UDim2 | Binding<UDim2>? }
type TextLabelProps = GuiLabelProps<TextLabel> & { Font: Enum.Font | Binding<Enum.Font>?, FontFace: Font | Binding<Font>?, LineHeight: number | Binding<number>?, MaxVisibleGraphemes: number | Binding<number>?, RichText: boolean | Binding<boolean>?, Text: string | Binding<string>?, TextColor3: Color3 | Binding<Color3>?, TextScaled: boolean | Binding<boolean>?, TextSize: number | Binding<number>?, TextStrokeColor3: Color3 | Binding<Color3>?, TextStrokeTransparency: number | Binding<number>?, TextTransparency: number | Binding<number>?, TextTruncate: Enum.TextTruncate | Binding<Enum.TextTruncate>?, TextWrapped: boolean | Binding<boolean>?, TextXAlignment: Enum.TextXAlignment | Binding<Enum.TextXAlignment>?, TextYAlignment: Enum.TextYAlignment | Binding<Enum.TextYAlignment>?, bindTextBounds: BindProperty<TextLabel>? }
type ScrollingFrameProps = GuiObjectProps<ScrollingFrame> & { AutomaticCanvasSize: Enum.AutomaticSize | Binding<Enum.AutomaticSize>?, BottomImage: string | Binding<string>?, CanvasPosition: Vector2 | Binding<Vector2>?, CanvasSize: UDim2 | Binding<UDim2>?, ElasticBehavior: Enum.ElasticBehavior | Binding<Enum.ElasticBehavior>?, HorizontalScrollBarInset: Enum.ScrollBarInset | Binding<Enum.ScrollBarInset>?, MidImage: string | Binding<string>?, ScrollBarImageColor3: Color3 | Binding<Color3>?, ScrollBarImageTransparency: number | Binding<number>?, ScrollBarThickness: number | Binding<number>?, ScrollingDirection: Enum.ScrollingDirection | Binding<Enum.ScrollingDirection>?, ScrollingEnabled: boolean | Binding<boolean>?, TopImage: string | Binding<string>?, VerticalScrollBarInset: Enum.ScrollBarInset | Binding<Enum.ScrollBarInset>?, VerticalScrollBarPosition: Enum.VerticalScrollBarPosition | Binding<Enum.VerticalScrollBarPosition>?, bindAbsoluteCanvasSize: BindProperty<ScrollingFrame>?, bindAbsoluteWindowSize: BindProperty<ScrollingFrame>? }
type TextBoxProps = GuiObjectProps<TextBox> & { ClearTextOnFocus: boolean | Binding<boolean>?, CursorPosition: number | Binding<number>?, Font: Enum.Font | Binding<Enum.Font>?, FontFace: Font | Binding<Font>?, LineHeight: number | Binding<number>?, MaxVisibleGraphemes: number | Binding<number>?, MultiLine: boolean | Binding<boolean>?, PlaceholderColor3: Color3 | Binding<Color3>?, PlaceholderText: string | Binding<string>?, RichText: boolean | Binding<boolean>?, SelectionStart: number | Binding<number>?, ShowNativeInput: boolean | Binding<boolean>?, Text: string | Binding<string>?, TextColor3: Color3 | Binding<Color3>?, TextEditable: boolean | Binding<boolean>?, TextScaled: boolean | Binding<boolean>?, TextSize: number | Binding<number>?, TextStrokeColor3: Color3 | Binding<Color3>?, TextStrokeTransparency: number | Binding<number>?, TextTransparency: number | Binding<number>?, TextTruncate: Enum.TextTruncate | Binding<Enum.TextTruncate>?, TextWrapped: boolean | Binding<boolean>?, TextXAlignment: Enum.TextXAlignment | Binding<Enum.TextXAlignment>?, TextYAlignment: Enum.TextYAlignment | Binding<Enum.TextYAlignment>?, bindText: BindProperty<TextBox>?, bindTextBounds: BindProperty<TextBox>?, onFocusLost: Event<TextBox, boolean, InputObject>?, onFocused: Event<TextBox>?, onReturnPressedFromOnScreenKeyboard: Event<TextBox>? }
type VideoFrameProps = GuiObjectProps<VideoFrame> & { Looped: boolean | Binding<boolean>?, Playing: boolean | Binding<boolean>?, TimePosition: number | Binding<number>?, Video: string | Binding<string>?, Volume: number | Binding<number>?, onDidLoop: Event<VideoFrame, string>?, onEnded: Event<VideoFrame, string>?, onLoaded: Event<VideoFrame, string>?, onPaused: Event<VideoFrame, string>?, onPlayed: Event<VideoFrame, string>? }
type ViewportFrameProps = GuiObjectProps<ViewportFrame> & { Ambient: Color3 | Binding<Color3>?, CurrentCamera: Camera | Binding<Camera>?, ImageColor3: Color3 | Binding<Color3>?, ImageTransparency: number | Binding<number>?, LightColor: Color3 | Binding<Color3>?, LightDirection: Vector3 | Binding<Vector3>? }
type BillboardGuiProps = LayerCollectorProps<BillboardGui> & { Active: boolean | Binding<boolean>?, Adornee: Instance | Binding<Instance>?, AlwaysOnTop: boolean | Binding<boolean>?, Brightness: number | Binding<number>?, ClipsDescendants: boolean | Binding<boolean>?, DistanceLowerLimit: number | Binding<number>?, DistanceStep: number | Binding<number>?, DistanceUpperLimit: number | Binding<number>?, ExtentsOffset: Vector3 | Binding<Vector3>?, ExtentsOffsetWorldSpace: Vector3 | Binding<Vector3>?, LightInfluence: number | Binding<number>?, MaxDistance: number | Binding<number>?, PlayerToHideFrom: Instance | Binding<Instance>?, Size: UDim2 | Binding<UDim2>?, SizeOffset: Vector2 | Binding<Vector2>?, StudsOffset: Vector3 | Binding<Vector3>?, StudsOffsetWorldSpace: Vector3 | Binding<Vector3>? }
type ScreenGuiProps = LayerCollectorProps<ScreenGui> & { ClipToDeviceSafeArea: boolean | Binding<boolean>?, DisplayOrder: number | Binding<number>?, IgnoreGuiInset: boolean | Binding<boolean>?, SafeAreaCompatibility: Enum.SafeAreaCompatibility | Binding<Enum.SafeAreaCompatibility>?, ScreenInsets: Enum.ScreenInsets | Binding<Enum.ScreenInsets>? }
type AdGuiProps = SurfaceGuiBaseProps<AdGui> & { AdShape: Enum.AdShape | Binding<Enum.AdShape>? }
type SurfaceGuiProps = SurfaceGuiBaseProps<SurfaceGui> & { AlwaysOnTop: boolean | Binding<boolean>?, Brightness: number | Binding<number>?, CanvasSize: Vector2 | Binding<Vector2>?, ClipsDescendants: boolean | Binding<boolean>?, LightInfluence: number | Binding<number>?, PixelsPerStud: number | Binding<number>?, SizingMode: Enum.SurfaceGuiSizingMode | Binding<Enum.SurfaceGuiSizingMode>?, ToolPunchThroughDistance: number | Binding<number>?, ZOffset: number | Binding<number>? }
type CornerWedgePartProps = BasePartProps<CornerWedgePart> & {  }
type SeatProps = PartProps<Seat> & { Disabled: boolean | Binding<boolean>? }
type SpawnLocationProps = PartProps<SpawnLocation> & { AllowTeamChangeOnTouch: boolean | Binding<boolean>?, Duration: number | Binding<number>?, Enabled: boolean | Binding<boolean>?, Neutral: boolean | Binding<boolean>?, TeamColor: BrickColor | Binding<BrickColor>? }
type WedgePartProps = FormFactorPartProps<WedgePart> & {  }
type MeshPartProps = TriangleMeshPartProps<MeshPart> & { TextureID: string | Binding<string>? }
type IntersectOperationProps = PartOperationProps<IntersectOperation> & {  }
type NegateOperationProps = PartOperationProps<NegateOperation> & {  }
type UnionOperationProps = PartOperationProps<UnionOperation> & {  }
type TrussPartProps = BasePartProps<TrussPart> & { Style: Enum.Style | Binding<Enum.Style>? }
type VehicleSeatProps = BasePartProps<VehicleSeat> & { Disabled: boolean | Binding<boolean>?, HeadsUpDisplay: boolean | Binding<boolean>?, MaxSpeed: number | Binding<number>?, Steer: number | Binding<number>?, SteerFloat: number | Binding<number>?, Throttle: number | Binding<number>?, ThrottleFloat: number | Binding<number>?, Torque: number | Binding<number>?, TurnSpeed: number | Binding<number>? }
type UIAspectRatioConstraintProps = UIConstraintProps<UIAspectRatioConstraint> & { AspectRatio: number | Binding<number>?, AspectType: Enum.AspectType | Binding<Enum.AspectType>?, DominantAxis: Enum.DominantAxis | Binding<Enum.DominantAxis>? }
type UISizeConstraintProps = UIConstraintProps<UISizeConstraint> & { MaxSize: Vector2 | Binding<Vector2>?, MinSize: Vector2 | Binding<Vector2>? }
type UITextSizeConstraintProps = UIConstraintProps<UITextSizeConstraint> & { MaxTextSize: number | Binding<number>?, MinTextSize: number | Binding<number>? }
type UICornerProps = UIComponentProps<UICorner> & { CornerRadius: UDim | Binding<UDim>? }
type UIGradientProps = UIComponentProps<UIGradient> & { Color: ColorSequence | Binding<ColorSequence>?, Enabled: boolean | Binding<boolean>?, Offset: Vector2 | Binding<Vector2>?, Rotation: number | Binding<number>?, Transparency: NumberSequence | Binding<NumberSequence>? }
type UIGridLayoutProps = UIGridStyleLayoutProps<UIGridLayout> & { CellPadding: UDim2 | Binding<UDim2>?, CellSize: UDim2 | Binding<UDim2>?, FillDirectionMaxCells: number | Binding<number>?, StartCorner: Enum.StartCorner | Binding<Enum.StartCorner>?, bindAbsoluteCellCount: BindProperty<UIGridLayout>?, bindAbsoluteCellSize: BindProperty<UIGridLayout>? }
type UIListLayoutProps = UIGridStyleLayoutProps<UIListLayout> & { Padding: UDim | Binding<UDim>? }
type UIPageLayoutProps = UIGridStyleLayoutProps<UIPageLayout> & { Animated: boolean | Binding<boolean>?, Circular: boolean | Binding<boolean>?, EasingDirection: Enum.EasingDirection | Binding<Enum.EasingDirection>?, EasingStyle: Enum.EasingStyle | Binding<Enum.EasingStyle>?, GamepadInputEnabled: boolean | Binding<boolean>?, Padding: UDim | Binding<UDim>?, ScrollWheelInputEnabled: boolean | Binding<boolean>?, TouchInputEnabled: boolean | Binding<boolean>?, TweenTime: number | Binding<number>?, onPageEnter: Event<UIPageLayout, Instance>?, onPageLeave: Event<UIPageLayout, Instance>?, onStopped: Event<UIPageLayout, Instance>? }
type UITableLayoutProps = UIGridStyleLayoutProps<UITableLayout> & { FillEmptySpaceColumns: boolean | Binding<boolean>?, FillEmptySpaceRows: boolean | Binding<boolean>?, MajorAxis: Enum.TableMajorAxis | Binding<Enum.TableMajorAxis>?, Padding: UDim2 | Binding<UDim2>? }
type UIPaddingProps = UIComponentProps<UIPadding> & { PaddingBottom: UDim | Binding<UDim>?, PaddingLeft: UDim | Binding<UDim>?, PaddingRight: UDim | Binding<UDim>?, PaddingTop: UDim | Binding<UDim>? }
type UIScaleProps = UIComponentProps<UIScale> & { Scale: number | Binding<number>? }
type UIStrokeProps = UIComponentProps<UIStroke> & { ApplyStrokeMode: Enum.ApplyStrokeMode | Binding<Enum.ApplyStrokeMode>?, Color: Color3 | Binding<Color3>?, Enabled: boolean | Binding<boolean>?, LineJoinMode: Enum.LineJoinMode | Binding<Enum.LineJoinMode>?, Thickness: number | Binding<number>?, Transparency: number | Binding<number>? }
-- stylua: ignore end
function froact.configure(config: {
	Roact: any,
	Hooks: HookFunction<any, any>,
	defaultProperties: { DefaultPropertyConfig }?,
	unpureByDefault: boolean?,
})
	local hooks: HookFunction<any, Hooks> = config.Hooks
	local e = newE(
		config.Roact,
		config.Hooks,
		if config.defaultProperties then config.defaultProperties else {}
	)
	local function apply(props: any)
		local toRemove = {}
		local toAdd = {}
		for name, value in props do
			if typeof(name) == "string" then
				if name:sub(1, 2) == "on" then
					toAdd[(config.Roact.Event :: any)[name:sub(3)]] = value
					toRemove[name] = true
				elseif name:sub(1, 4) == "bind" then
					toAdd[(config.Roact.Change :: any)[name:sub(5)]] = value
					toRemove[name] = true
				end
			end
		end
		for name, value in toAdd do
			props[name] = value
		end
		for name, _ in toRemove do
			props[name] = nil
		end
		if props.ref then
			props[config.Roact.Ref] = props.ref
			props.ref = nil
		end
	end
	-- stylua: ignore start
	local function Camera(props: CameraProps, children)
		apply(props)
		return e("Camera", props, children)
	end
	local function CanvasGroup(props: CanvasGroupProps, children)
		apply(props)
		return e("CanvasGroup", props, children)
	end
	local function Frame(props: FrameProps, children)
		apply(props)
		return e("Frame", props, children)
	end
	local function ImageButton(props: ImageButtonProps, children)
		apply(props)
		return e("ImageButton", props, children)
	end
	local function TextButton(props: TextButtonProps, children)
		apply(props)
		return e("TextButton", props, children)
	end
	local function ImageLabel(props: ImageLabelProps, children)
		apply(props)
		return e("ImageLabel", props, children)
	end
	local function TextLabel(props: TextLabelProps, children)
		apply(props)
		return e("TextLabel", props, children)
	end
	local function ScrollingFrame(props: ScrollingFrameProps, children)
		apply(props)
		return e("ScrollingFrame", props, children)
	end
	local function TextBox(props: TextBoxProps, children)
		apply(props)
		return e("TextBox", props, children)
	end
	local function VideoFrame(props: VideoFrameProps, children)
		apply(props)
		return e("VideoFrame", props, children)
	end
	local function ViewportFrame(props: ViewportFrameProps, children)
		apply(props)
		return e("ViewportFrame", props, children)
	end
	local function BillboardGui(props: BillboardGuiProps, children)
		apply(props)
		return e("BillboardGui", props, children)
	end
	local function ScreenGui(props: ScreenGuiProps, children)
		apply(props)
		return e("ScreenGui", props, children)
	end
	local function AdGui(props: AdGuiProps, children)
		apply(props)
		return e("AdGui", props, children)
	end
	local function SurfaceGui(props: SurfaceGuiProps, children)
		apply(props)
		return e("SurfaceGui", props, children)
	end
	local function CornerWedgePart(props: CornerWedgePartProps, children)
		apply(props)
		return e("CornerWedgePart", props, children)
	end
	local function Part(props: PartProps<Part>, children)
		apply(props)
		return e("Part", props, children)
	end
	local function Seat(props: SeatProps, children)
		apply(props)
		return e("Seat", props, children)
	end
	local function SpawnLocation(props: SpawnLocationProps, children)
		apply(props)
		return e("SpawnLocation", props, children)
	end
	local function WedgePart(props: WedgePartProps, children)
		apply(props)
		return e("WedgePart", props, children)
	end
	local function MeshPart(props: MeshPartProps, children)
		apply(props)
		return e("MeshPart", props, children)
	end
	local function PartOperation(props: PartOperationProps<PartOperation>, children)
		apply(props)
		return e("PartOperation", props, children)
	end
	local function IntersectOperation(props: IntersectOperationProps, children)
		apply(props)
		return e("IntersectOperation", props, children)
	end
	local function NegateOperation(props: NegateOperationProps, children)
		apply(props)
		return e("NegateOperation", props, children)
	end
	local function UnionOperation(props: UnionOperationProps, children)
		apply(props)
		return e("UnionOperation", props, children)
	end
	local function TrussPart(props: TrussPartProps, children)
		apply(props)
		return e("TrussPart", props, children)
	end
	local function VehicleSeat(props: VehicleSeatProps, children)
		apply(props)
		return e("VehicleSeat", props, children)
	end
	local function UIAspectRatioConstraint(props: UIAspectRatioConstraintProps, children)
		apply(props)
		return e("UIAspectRatioConstraint", props, children)
	end
	local function UISizeConstraint(props: UISizeConstraintProps, children)
		apply(props)
		return e("UISizeConstraint", props, children)
	end
	local function UITextSizeConstraint(props: UITextSizeConstraintProps, children)
		apply(props)
		return e("UITextSizeConstraint", props, children)
	end
	local function UICorner(props: UICornerProps, children)
		apply(props)
		return e("UICorner", props, children)
	end
	local function UIGradient(props: UIGradientProps, children)
		apply(props)
		return e("UIGradient", props, children)
	end
	local function UIGridLayout(props: UIGridLayoutProps, children)
		apply(props)
		return e("UIGridLayout", props, children)
	end
	local function UIListLayout(props: UIListLayoutProps, children)
		apply(props)
		return e("UIListLayout", props, children)
	end
	local function UIPageLayout(props: UIPageLayoutProps, children)
		apply(props)
		return e("UIPageLayout", props, children)
	end
	local function UITableLayout(props: UITableLayoutProps, children)
		apply(props)
		return e("UITableLayout", props, children)
	end
	local function UIPadding(props: UIPaddingProps, children)
		apply(props)
		return e("UIPadding", props, children)
	end
	local function UIScale(props: UIScaleProps, children)
		apply(props)
		return e("UIScale", props, children)
	end
	local function UIStroke(props: UIStrokeProps, children)
		apply(props)
		return e("UIStroke", props, children)
	end
	-- stylua: ignore end
	return {
		Roact = config.Roact,
		Hooks = hooks,
		e = e,
		c = newC(config.Roact, hooks, config.unpureByDefault),
		list = newList(config.Roact),
		template = newTemplate(config.Roact, config.unpureByDefault),
		createRef = newCreateRef(config.Roact),
		createBinding = newCreateBinding(config.Roact),
		join = newJoin(config.Roact),
		map = newMap(config.Roact),
		Camera = Camera,
		CanvasGroup = CanvasGroup,
		Frame = Frame,
		ImageButton = ImageButton,
		TextButton = TextButton,
		ImageLabel = ImageLabel,
		TextLabel = TextLabel,
		ScrollingFrame = ScrollingFrame,
		TextBox = TextBox,
		VideoFrame = VideoFrame,
		ViewportFrame = ViewportFrame,
		BillboardGui = BillboardGui,
		ScreenGui = ScreenGui,
		AdGui = AdGui,
		SurfaceGui = SurfaceGui,
		CornerWedgePart = CornerWedgePart,
		Part = Part,
		Seat = Seat,
		SpawnLocation = SpawnLocation,
		WedgePart = WedgePart,
		MeshPart = MeshPart,
		PartOperation = PartOperation,
		IntersectOperation = IntersectOperation,
		NegateOperation = NegateOperation,
		UnionOperation = UnionOperation,
		TrussPart = TrussPart,
		VehicleSeat = VehicleSeat,
		UIAspectRatioConstraint = UIAspectRatioConstraint,
		UISizeConstraint = UISizeConstraint,
		UITextSizeConstraint = UITextSizeConstraint,
		UICorner = UICorner,
		UIGradient = UIGradient,
		UIGridLayout = UIGridLayout,
		UIListLayout = UIListLayout,
		UIPageLayout = UIPageLayout,
		UITableLayout = UITableLayout,
		UIPadding = UIPadding,
		UIScale = UIScale,
		UIStroke = UIStroke,
	}
end

return froact
